<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow Field Particles</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0a;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 30, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            color: white;
            font-size: 13px;
            max-width: 280px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .controls h2 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: 600;
            color: #4ecdc4;
        }
        .control-group {
            margin-bottom: 12px;
        }
        .control-group label {
            display: block;
            margin-bottom: 4px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.8;
        }
        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: rgba(255,255,255,0.1);
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #4ecdc4;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #4ecdc4;
            cursor: pointer;
            border: none;
        }
        .value {
            float: right;
            color: #4ecdc4;
            font-weight: 600;
        }
        button {
            width: 100%;
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            margin-top: 10px;
            transition: transform 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
        }
        .nav {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
        }
        .nav a {
            background: rgba(20, 20, 30, 0.9);
            backdrop-filter: blur(10px);
            color: white;
            padding: 10px 16px;
            text-decoration: none;
            border-radius: 8px;
            font-size: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.2s;
        }
        .nav a:hover {
            background: rgba(40, 40, 50, 0.9);
            border-color: #4ecdc4;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h2>Flow Field</h2>
        <div class="control-group">
            <label>Noise Scale <span class="value" id="scaleVal">0.003</span></label>
            <input type="range" id="scale" min="0.0005" max="0.01" step="0.0005" value="0.003">
        </div>
        <div class="control-group">
            <label>Speed <span class="value" id="speedVal">1.5</span></label>
            <input type="range" id="speed" min="0.5" max="5" step="0.1" value="1.5">
        </div>
        <div class="control-group">
            <label>Particles <span class="value" id="countVal">3000</span></label>
            <input type="range" id="count" min="500" max="5000" step="100" value="3000">
        </div>
        <button id="reset">Reset</button>
    </div>

    <div class="nav">
        <a href="index.html">Flocking</a>
        <a href="cellular.html">Cellular Automata</a>
        <a href="gravity.html">Gravity Well</a>
    </div>

    <script>
        console.log('Flow Field initialized');

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            reset();
        });

        // Perlin noise implementation
        class PerlinNoise {
            constructor() {
                this.p = [];
                for (let i = 0; i < 256; i++) this.p[i] = Math.floor(Math.random() * 256);
                for (let i = 0; i < 256; i++) this.p[256 + i] = this.p[i];
            }

            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }
            grad(hash, x, y) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const a = this.p[X] + Y;
                const aa = this.p[a];
                const ab = this.p[a + 1];
                const b = this.p[X + 1] + Y;
                const ba = this.p[b];
                const bb = this.p[b + 1];

                return this.lerp(v,
                    this.lerp(u, this.grad(this.p[aa], x, y), this.grad(this.p[ba], x - 1, y)),
                    this.lerp(u, this.grad(this.p[ab], x, y - 1), this.grad(this.p[bb], x - 1, y - 1))
                );
            }
        }

        const perlin = new PerlinNoise();

        let params = {
            scale: 0.003,
            speed: 1.5,
            count: 3000
        };

        // Controls
        ['scale', 'speed', 'count'].forEach(id => {
            const input = document.getElementById(id);
            const display = document.getElementById(id + 'Val');
            input.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                display.textContent = id === 'scale' ? val.toFixed(4) : val.toFixed(0);
                params[id] = val;
                if (id === 'count') reset();
            });
        });

        document.getElementById('reset').addEventListener('click', reset);

        class Particle {
            constructor() {
                this.pos = {
                    x: Math.random() * width,
                    y: Math.random() * height
                };
                this.vel = { x: 0, y: 0 };
                this.maxSpeed = params.speed;
                this.prevPos = { ...this.pos };
                this.hue = Math.random() * 60 + 150;
                this.alpha = 0.8;
            }

            follow(field) {
                const x = Math.floor(this.pos.x / 20);
                const y = Math.floor(this.pos.y / 20);
                const index = x + y * Math.ceil(width / 20);
                if (field[index]) {
                    const force = field[index];
                    this.vel.x += force.x * 0.1;
                    this.vel.y += force.y * 0.1;
                }
            }

            update() {
                this.prevPos = { ...this.pos };

                this.pos.x += this.vel.x;
                this.pos.y += this.vel.y;

                // Limit velocity
                const speed = Math.sqrt(this.vel.x * this.vel.x + this.vel.y * this.vel.y);
                if (speed > this.maxSpeed) {
                    this.vel.x = (this.vel.x / speed) * this.maxSpeed;
                    this.vel.y = (this.vel.y / speed) * this.maxSpeed;
                }

                // Wrap edges
                if (this.pos.x > width) {
                    this.pos.x = 0;
                    this.prevPos.x = 0;
                }
                if (this.pos.x < 0) {
                    this.pos.x = width;
                    this.prevPos.x = width;
                }
                if (this.pos.y > height) {
                    this.pos.y = 0;
                    this.prevPos.y = 0;
                }
                if (this.pos.y < 0) {
                    this.pos.y = height;
                    this.prevPos.y = height;
                }

                // Update speed-based properties
                this.maxSpeed = params.speed;
            }

            draw() {
                ctx.strokeStyle = `hsla(${this.hue}, 70%, 60%, ${this.alpha})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(this.prevPos.x, this.prevPos.y);
                ctx.lineTo(this.pos.x, this.pos.y);
                ctx.stroke();
            }
        }

        let particles = [];
        let flowField = [];
        let time = 0;

        function reset() {
            particles = [];
            for (let i = 0; i < params.count; i++) {
                particles.push(new Particle());
            }
            console.log(`Created ${params.count} particles`);
        }

        function calculateFlowField() {
            const cols = Math.ceil(width / 20);
            const rows = Math.ceil(height / 20);
            flowField = [];

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const angle = perlin.noise(
                        x * params.scale + time * 0.0002,
                        y * params.scale + time * 0.0002
                    ) * Math.PI * 4;

                    flowField.push({
                        x: Math.cos(angle),
                        y: Math.sin(angle)
                    });
                }
            }
        }

        function animate() {
            ctx.fillStyle = 'rgba(10, 10, 10, 0.05)';
            ctx.fillRect(0, 0, width, height);

            calculateFlowField();

            for (let particle of particles) {
                particle.follow(flowField);
                particle.update();
                particle.draw();
            }

            time++;
            requestAnimationFrame(animate);
        }

        reset();
        animate();
    </script>
</body>
</html>
