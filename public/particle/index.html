<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flocking Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0a;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 30, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            color: white;
            font-size: 13px;
            max-width: 280px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .controls h2 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: 600;
            color: #6c9fff;
        }
        .control-group {
            margin-bottom: 12px;
        }
        .control-group label {
            display: block;
            margin-bottom: 4px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.8;
        }
        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: rgba(255,255,255,0.1);
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #6c9fff;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #6c9fff;
            cursor: pointer;
            border: none;
        }
        .value {
            float: right;
            color: #6c9fff;
            font-weight: 600;
        }
        .nav {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
        }
        .nav a {
            background: rgba(20, 20, 30, 0.9);
            backdrop-filter: blur(10px);
            color: white;
            padding: 10px 16px;
            text-decoration: none;
            border-radius: 8px;
            font-size: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.2s;
        }
        .nav a:hover {
            background: rgba(40, 40, 50, 0.9);
            border-color: #6c9fff;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h2>Flocking Rules</h2>
        <div class="control-group">
            <label>Separation <span class="value" id="separationVal">1.5</span></label>
            <input type="range" id="separation" min="0" max="3" step="0.1" value="1.5">
        </div>
        <div class="control-group">
            <label>Alignment <span class="value" id="alignmentVal">1.0</span></label>
            <input type="range" id="alignment" min="0" max="3" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label>Cohesion <span class="value" id="cohesionVal">1.0</span></label>
            <input type="range" id="cohesion" min="0" max="3" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label>Max Speed <span class="value" id="speedVal">2.5</span></label>
            <input type="range" id="speed" min="1" max="5" step="0.1" value="2.5">
        </div>
        <div class="control-group">
            <label>Perception <span class="value" id="perceptionVal">60</span></label>
            <input type="range" id="perception" min="20" max="150" step="5" value="60">
        </div>
    </div>

    <div class="nav">
        <a href="cellular.html">Cellular Automata</a>
        <a href="flow.html">Flow Field</a>
        <a href="gravity.html">Gravity Well</a>
    </div>

    <script>
        console.log('Flocking Simulation initialized');

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });

        // Parameters
        let params = {
            separation: 1.5,
            alignment: 1.0,
            cohesion: 1.0,
            maxSpeed: 2.5,
            perception: 60
        };

        // Controls
        ['separation', 'alignment', 'cohesion', 'speed', 'perception'].forEach(id => {
            const input = document.getElementById(id);
            const display = document.getElementById(id + 'Val');
            input.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                display.textContent = val.toFixed(1);
                if (id === 'speed') params.maxSpeed = val;
                else if (id === 'perception') params[id] = val;
                else params[id] = val;
            });
        });

        class Vector {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            add(v) {
                this.x += v.x;
                this.y += v.y;
                return this;
            }

            sub(v) {
                this.x -= v.x;
                this.y -= v.y;
                return this;
            }

            mult(n) {
                this.x *= n;
                this.y *= n;
                return this;
            }

            div(n) {
                if (n !== 0) {
                    this.x /= n;
                    this.y /= n;
                }
                return this;
            }

            mag() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }

            normalize() {
                const m = this.mag();
                if (m !== 0) this.div(m);
                return this;
            }

            limit(max) {
                const m = this.mag();
                if (m > max) {
                    this.normalize().mult(max);
                }
                return this;
            }

            copy() {
                return new Vector(this.x, this.y);
            }

            static sub(v1, v2) {
                return new Vector(v1.x - v2.x, v1.y - v2.y);
            }

            static dist(v1, v2) {
                const dx = v1.x - v2.x;
                const dy = v1.y - v2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }

        class Boid {
            constructor(x, y) {
                this.pos = new Vector(x, y);
                this.vel = new Vector(Math.random() * 2 - 1, Math.random() * 2 - 1);
                this.acc = new Vector(0, 0);
                this.maxForce = 0.2;
                this.trail = [];
                this.trailLength = 30;
                this.hue = Math.random() * 60 + 180; // Blue-cyan range
            }

            edges() {
                if (this.pos.x > width) this.pos.x = 0;
                else if (this.pos.x < 0) this.pos.x = width;
                if (this.pos.y > height) this.pos.y = 0;
                else if (this.pos.y < 0) this.pos.y = height;
            }

            align(nearby) {
                const steering = new Vector(0, 0);
                let total = 0;

                for (let other of nearby) {
                    const d = Vector.dist(this.pos, other.pos);
                    if (other !== this && d < params.perception) {
                        steering.add(other.vel);
                        total++;
                    }
                }

                if (total > 0) {
                    steering.div(total);
                    steering.normalize().mult(params.maxSpeed);
                    steering.sub(this.vel);
                    steering.limit(this.maxForce);
                }

                return steering;
            }

            cohesion(nearby) {
                const steering = new Vector(0, 0);
                let total = 0;

                for (let other of nearby) {
                    const d = Vector.dist(this.pos, other.pos);
                    if (other !== this && d < params.perception) {
                        steering.add(other.pos);
                        total++;
                    }
                }

                if (total > 0) {
                    steering.div(total);
                    steering.sub(this.pos);
                    steering.normalize().mult(params.maxSpeed);
                    steering.sub(this.vel);
                    steering.limit(this.maxForce);
                }

                return steering;
            }

            separation(nearby) {
                const steering = new Vector(0, 0);
                let total = 0;

                for (let other of nearby) {
                    const d = Vector.dist(this.pos, other.pos);
                    if (other !== this && d < params.perception * 0.5) {
                        const diff = Vector.sub(this.pos, other.pos);
                        diff.div(d * d); // Weight by distance
                        steering.add(diff);
                        total++;
                    }
                }

                if (total > 0) {
                    steering.div(total);
                    steering.normalize().mult(params.maxSpeed);
                    steering.sub(this.vel);
                    steering.limit(this.maxForce);
                }

                return steering;
            }

            flock(nearby) {
                const alignment = this.align(nearby);
                const cohesion = this.cohesion(nearby);
                const separation = this.separation(nearby);

                alignment.mult(params.alignment);
                cohesion.mult(params.cohesion);
                separation.mult(params.separation);

                this.acc.add(alignment);
                this.acc.add(cohesion);
                this.acc.add(separation);
            }

            update() {
                this.pos.add(this.vel);
                this.vel.add(this.acc);
                this.vel.limit(params.maxSpeed);
                this.acc.mult(0);

                this.trail.push(this.pos.copy());
                if (this.trail.length > this.trailLength) {
                    this.trail.shift();
                }
            }

            draw() {
                // Draw smooth trail
                if (this.trail.length > 1) {
                    ctx.strokeStyle = `hsla(${this.hue}, 70%, 60%, 0.4)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);

                    for (let i = 1; i < this.trail.length; i++) {
                        const alpha = (i / this.trail.length) * 0.5;
                        ctx.strokeStyle = `hsla(${this.hue}, 70%, 60%, ${alpha})`;
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.stroke();
                }

                // Draw boid
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                const angle = Math.atan2(this.vel.y, this.vel.x);
                ctx.rotate(angle);

                // Glow effect
                ctx.shadowBlur = 8;
                ctx.shadowColor = `hsla(${this.hue}, 80%, 60%, 0.8)`;

                ctx.fillStyle = `hsla(${this.hue}, 80%, 60%, 0.9)`;
                ctx.beginPath();
                ctx.moveTo(8, 0);
                ctx.lineTo(-4, 4);
                ctx.lineTo(-2, 0);
                ctx.lineTo(-4, -4);
                ctx.closePath();
                ctx.fill();

                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }

        // Spatial partitioning grid
        class SpatialGrid {
            constructor(cellSize) {
                this.cellSize = cellSize;
                this.grid = new Map();
            }

            clear() {
                this.grid.clear();
            }

            hash(x, y) {
                const col = Math.floor(x / this.cellSize);
                const row = Math.floor(y / this.cellSize);
                return `${col},${row}`;
            }

            insert(boid) {
                const key = this.hash(boid.pos.x, boid.pos.y);
                if (!this.grid.has(key)) {
                    this.grid.set(key, []);
                }
                this.grid.get(key).push(boid);
            }

            query(boid, radius) {
                const nearby = [];
                const cellRadius = Math.ceil(radius / this.cellSize);
                const col = Math.floor(boid.pos.x / this.cellSize);
                const row = Math.floor(boid.pos.y / this.cellSize);

                for (let i = -cellRadius; i <= cellRadius; i++) {
                    for (let j = -cellRadius; j <= cellRadius; j++) {
                        const key = `${col + i},${row + j}`;
                        if (this.grid.has(key)) {
                            nearby.push(...this.grid.get(key));
                        }
                    }
                }

                return nearby;
            }
        }

        const spatialGrid = new SpatialGrid(100);

        // Create flock
        const flock = [];
        const numBoids = 300;

        for (let i = 0; i < numBoids; i++) {
            const boid = new Boid(Math.random() * width, Math.random() * height);
            boid.hue = 180 + (i / numBoids) * 80; // Color gradient
            flock.push(boid);
        }

        console.log(`Created ${numBoids} boids with spatial partitioning`);

        // Animation loop
        function animate() {
            ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
            ctx.fillRect(0, 0, width, height);

            // Rebuild spatial grid
            spatialGrid.clear();
            for (let boid of flock) {
                spatialGrid.insert(boid);
            }

            // Update boids using spatial partitioning
            for (let boid of flock) {
                boid.edges();
                const nearby = spatialGrid.query(boid, params.perception);
                boid.flock(nearby);
                boid.update();
                boid.draw();
            }

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
